![Diagnostic Plots](main/AmpuleBreakageDiagnostics.pdf)

# Glass Ampule Breakage Analysis
# Author: Robert Yates
# Date: November 2024
# Description: Analysis of the relationship between number of airfreight transfers
# and glass ampule breakage rates using various regression techniques. Small (n=10) dataset.

# Loading utilized packages
library(ggplot2)
library(dplyr)
library(gridExtra)
library(car)
library(lmtest)

# 1. Loading Data
load_and_prepare_data <- function(file_path = "CH01PR21.csv") {
  data <- read.csv(file_path, header = TRUE)
  colnames(data) <- c("broken_ampules", "transfers")
  return(data)
}

# 2. EDA
calculate_summary_stats <- function(data) {
  summary_stats <- list(
    basic_summary = summary(data),
    correlation = cor(data$transfers, data$broken_ampules),
    mean_broken = mean(data$broken_ampules),
    sd_broken = sd(data$broken_ampules),
    n = nrow(data)
  )
  return(summary_stats)
}

create_eda_plots <- function(data) {
  # Scatter plot with regression line
  p1 <- ggplot(data, aes(x = transfers, y = broken_ampules)) +
    geom_point(color = "blue", size = 3) +
    geom_smooth(method = "lm", se = TRUE, fill = "lightblue") +
    labs(title = "Glass Ampule Breakage vs Number of Transfers",
         x = "Number of Transfers",
         y = "Number of Broken Ampules") +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10)
    ) +
    scale_x_continuous(breaks = seq(0, max(data$transfers), by = 1)) +
    annotate("text", 
             x = max(data$transfers) * 0.2, 
             y = max(data$broken_ampules) * 0.9,
             label = paste("R² =", round(summary(lm(broken_ampules ~ transfers, data))$r.squared, 3)),
             size = 4)
  
  # Distribution of broken ampules
  p2 <- ggplot(data, aes(x = broken_ampules)) +
    geom_histogram(fill = "blue", alpha = 0.7, bins = 8) +
    labs(title = "Distribution of Broken Ampules",
         x = "Number of Broken Ampules",
         y = "Frequency") +
    theme_minimal()
  
  return(list(scatter = p1, hist = p2))
}

# 3. Regression Analysis Functions ----
perform_regression <- function(data) {
  # Fit linear model
  model <- lm(broken_ampules ~ transfers, data)
  
  # Calculate key statistics
  n <- nrow(data)
  SSE <- sum(residuals(model)^2)
  SSR <- sum((predict(model) - mean(data$broken_ampules))^2)
  SSTO <- SSE + SSR
  MSR <- SSR/1
  MSE <- SSE/(n-2)
  R_squared <- 1 - SSE/SSTO
  adj_R_squared <- 1 - (SSE/(n-2))/(SSTO/(n-1))
  F_stat <- MSR/MSE
  
  # Compile results
  results <- list(
    model = model,
    summary = summary(model),
    statistics = list(
      SSE = SSE,
      SSR = SSR,
      SSTO = SSTO,
      MSE = MSE,
      MSR = MSR,
      R_squared = R_squared,
      adj_R_squared = adj_R_squared,
      F_statistic = F_stat,
      p_value = pf(F_stat, 1, n-2, lower.tail = FALSE)
    )
  )
  
  return(results)
}

# 4. Enhanced Diagnostic Plots ----
create_diagnostic_plots <- function(model) {
  # Get model data
  df <- data.frame(
    fitted = fitted(model),
    residuals = residuals(model),
    std_residuals = rstandard(model),
    leverage = hatvalues(model),
    cook_dist = cooks.distance(model)
  )
  
  # 1. Residuals vs Fitted
  p1 <- ggplot(df, aes(x = fitted, y = residuals)) +
    geom_point(aes(color = abs(std_residuals)), size = 3) +
    scale_color_gradient(low = "blue", high = "red") +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    labs(title = "Residuals vs Fitted",
         x = "Fitted values",
         y = "Residuals") +
    theme_minimal() +
    theme(legend.position = "none")
  
  # 2. Normal Q-Q Plot
  qq_data <- data.frame(
    theoretical = qqnorm(df$std_residuals, plot.it = FALSE)$x,
    sample = qqnorm(df$std_residuals, plot.it = FALSE)$y
  )
  
  p2 <- ggplot(qq_data, aes(x = theoretical, y = sample)) +
    geom_point(size = 3, color = "blue") +
    geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
    labs(title = "Normal Q-Q Plot",
         x = "Theoretical Quantiles",
         y = "Standardized Residuals") +
    theme_minimal()
  
  # 3. Scale-Location Plot
  p3 <- ggplot(df, aes(x = fitted, y = sqrt(abs(std_residuals)))) +
    geom_point(aes(color = sqrt(abs(std_residuals))), size = 3) +
    scale_color_gradient(low = "blue", high = "red") +
    labs(title = "Scale-Location Plot",
         x = "Fitted values",
         y = "√|Standardized Residuals|") +
    theme_minimal() +
    theme(legend.position = "none")
  
  # 4. Residuals vs Leverage Plot
  p4 <- ggplot(df, aes(x = leverage, y = std_residuals)) +
    geom_point(aes(size = cook_dist), color = "blue") +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    geom_vline(xintercept = 2 * mean(df$leverage), linetype = "dashed", color = "red") +
    labs(title = "Residuals vs Leverage",
         x = "Leverage",
         y = "Standardized Residuals",
         size = "Cook's distance") +
    theme_minimal() +
    scale_size_continuous(range = c(1, 6))
  
  # Return both arranged plots and individual plots
  return(list(
    residuals_vs_fitted = p1,
    qq_plot = p2,
    scale_location = p3,
    residuals_vs_leverage = p4
  ))
}

# 5. Interval Calculations ----
calculate_intervals <- function(model, newdata, level = 0.95) {
  # Confidence intervals for parameters
  param_intervals <- confint(model, level = level)
  
  # Confidence intervals for mean response
  conf_intervals <- predict(model, newdata = newdata, 
                            interval = "confidence", level = level)
  
  # Prediction intervals
  pred_intervals <- predict(model, newdata = newdata,
                            interval = "prediction", level = level)
  
  return(list(
    parameters = param_intervals,
    confidence = conf_intervals,
    prediction = pred_intervals
  ))
}

# 6. Matrix Calculations ----
calculate_matrices <- function(data) {
  # Create X matrix (including intercept)
  X <- cbind(1, data$transfers)
  Y <- matrix(data$broken_ampules)
  
  # Calculate matrices
  XtX <- t(X) %*% X
  XtY <- t(X) %*% Y
  beta_hat <- solve(XtX) %*% XtY
  H <- X %*% solve(XtX) %*% t(X)
  
  return(list(
    X = X,
    Y = Y,
    XtX = XtX,
    XtY = XtY,
    beta_hat = beta_hat,
    H = H
  ))
}

# 7. Main Analysis Function for Summarizing Findings
main_analysis <- function() {
  # Load data
  data <- load_and_prepare_data()
  
  # Perform EDA
  summary_stats <- calculate_summary_stats(data)
  eda_plots <- create_eda_plots(data)
  
  # Regression analysis
  reg_results <- perform_regression(data)
  
  # Diagnostic plots
  diag_plots <- create_diagnostic_plots(reg_results$model)
  
  # Calculate intervals
  newdata <- data.frame(transfers = seq(0, 3, by = 1))
  intervals <- calculate_intervals(reg_results$model, newdata)
  
  # Matrix calculations
  matrices <- calculate_matrices(data)
  
  # Return all results
  return(list(
    data = data,
    summary_stats = summary_stats,
    eda_plots = eda_plots,
    regression = reg_results,
    diagnostics = diag_plots,
    intervals = intervals,
    matrices = matrices
  ))
}

# 8. Function to Print Results
print_results <- function(results) {
  # Print summary statistics
  cat("\n=== Summary Statistics ===\n")
  print(results$summary_stats$basic_summary)
  cat("\nCorrelation between transfers and breakage:", 
      round(results$summary_stats$correlation, 4))
  
  # Print regression results
  cat("\n\n=== Regression Analysis ===\n")
  print(results$regression$summary)
  
  # Print additional statistics
  cat("\n=== Model Statistics ===\n")
  stats <- results$regression$statistics
  cat("R-squared:", round(stats$R_squared, 4), "\n")
  cat("Adjusted R-squared:", round(stats$adj_R_squared, 4), "\n")
  cat("F-statistic:", round(stats$F_statistic, 4), "\n")
  cat("p-value:", format.pval(stats$p_value, digits = 4), "\n")
  cat("MSE:", round(stats$MSE, 4), "\n")
  
  # Display confidence intervals
  cat("\n=== Parameter Confidence Intervals ===\n")
  print(results$intervals$parameters)
  
  # Create plots
  # EDA plots
  grid.arrange(
    results$eda_plots$scatter,
    results$eda_plots$hist,
    ncol = 2,
    top = "Exploratory Data Analysis"
  )
  
  # Diagnostic plots
  grid.arrange(
    results$diagnostics$residuals_vs_fitted,
    results$diagnostics$qq_plot,
    results$diagnostics$scale_location,
    results$diagnostics$residuals_vs_leverage,
    ncol = 2,
    top = "Diagnostic Plots"
  )
}

# 9. Execute Analysis
results <- main_analysis()
print_results(results)

# 10. Save Results
save(results, file = "ampule_analysis_results.RData")

  print(summary(model))
  sink()
}
